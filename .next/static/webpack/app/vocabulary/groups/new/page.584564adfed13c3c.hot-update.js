"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/vocabulary/groups/new/page",{

/***/ "(app-pages-browser)/./src/lib/supabase/vocabulary.ts":
/*!****************************************!*\
  !*** ./src/lib/supabase/vocabulary.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   vocabularyService: function() { return /* binding */ vocabularyService; }\n/* harmony export */ });\n/* harmony import */ var _supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/auth-helpers-nextjs */ \"(app-pages-browser)/./node_modules/@supabase/auth-helpers-nextjs/dist/index.js\");\n/* harmony import */ var _supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_0__);\n\nconst supabase = (0,_supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_0__.createClientComponentClient)();\nconst vocabularyService = {\n    // ==================== VOCABULARY ITEMS ====================\n    // Get all vocabulary items with optional filters\n    async getVocabulary () {\n        let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        let query = supabase.from(\"vocabulary\").select(\"*\").order(\"word\", {\n            ascending: true\n        });\n        // Apply filters\n        if (filters.search) {\n            query = query.or(\"word.ilike.%\".concat(filters.search, \"%,translation.ilike.%\").concat(filters.search, \"%,definition.ilike.%\").concat(filters.search, \"%\"));\n        }\n        if (filters.difficulty) {\n            query = query.eq(\"difficulty\", filters.difficulty);\n        }\n        if (filters.partOfSpeech) {\n            query = query.eq(\"part_of_speech\", filters.partOfSpeech);\n        }\n        if (filters.tags && filters.tags.length > 0) {\n            query = query.contains(\"tags\", filters.tags);\n        }\n        const { data, error } = await query;\n        if (error) throw error;\n        return data;\n    },\n    // Get vocabulary items in a specific group\n    async getVocabularyInGroup (groupId) {\n        const { data, error } = await supabase.from(\"vocabulary_group_items\").select(\"\\n        *,\\n        vocabulary(*)\\n      \").eq(\"vocabulary_group_id\", groupId).order(\"position\", {\n            ascending: true\n        });\n        if (error) throw error;\n        return data;\n    },\n    // Get single vocabulary item by ID\n    async getVocabularyItem (id) {\n        const { data, error } = await supabase.from(\"vocabulary\").select(\"*\").eq(\"id\", id).single();\n        if (error) throw error;\n        return data;\n    },\n    // Create new vocabulary item\n    async createVocabulary (vocabularyData) {\n        const { data: user } = await supabase.auth.getUser();\n        if (!user.user) throw new Error(\"User not authenticated\");\n        const dataWithDefaults = {\n            ...vocabularyData,\n            difficulty: vocabularyData.difficulty || \"beginner\",\n            user_id: user.user.id\n        };\n        const { data, error } = await supabase.from(\"vocabulary\").insert(dataWithDefaults).select().single();\n        if (error) throw error;\n        return data;\n    },\n    // Update vocabulary item\n    async updateVocabulary (param) {\n        let { id, ...vocabularyData } = param;\n        const { data, error } = await supabase.from(\"vocabulary\").update({\n            ...vocabularyData,\n            updated_at: new Date().toISOString()\n        }).eq(\"id\", id).select().single();\n        if (error) throw error;\n        return data;\n    },\n    // Delete vocabulary item\n    async deleteVocabulary (id) {\n        const { error } = await supabase.from(\"vocabulary\").delete().eq(\"id\", id);\n        if (error) throw error;\n    },\n    // ==================== VOCABULARY GROUPS ====================\n    // Get all vocabulary groups with optional filters\n    async getVocabularyGroups () {\n        let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        let query = supabase.from(\"vocabulary_groups\").select(\"\\n        *,\\n        category:categories(id, name, color, icon),\\n        vocabulary_group_items(count),\\n        vocabulary_group_books(\\n          book:books(\\n            id,\\n            title,\\n            author,\\n            cover_image_url\\n          )\\n        )\\n      \").order(\"created_at\", {\n            ascending: false\n        });\n        // Apply filters\n        if (filters.search) {\n            query = query.or(\"name.ilike.%\".concat(filters.search, \"%,description.ilike.%\").concat(filters.search, \"%\"));\n        }\n        if (filters.difficulty) {\n            query = query.eq(\"difficulty\", filters.difficulty);\n        }\n        if (filters.language) {\n            query = query.eq(\"language\", filters.language);\n        }\n        if (filters.targetLanguage) {\n            query = query.eq(\"target_language\", filters.targetLanguage);\n        }\n        if (filters.categoryId) {\n            query = query.eq(\"category_id\", filters.categoryId);\n        }\n        if (filters.isPublic !== undefined) {\n            query = query.eq(\"is_public\", filters.isPublic);\n        }\n        if (filters.tags && filters.tags.length > 0) {\n            query = query.contains(\"tags\", filters.tags);\n        }\n        const { data, error } = await query;\n        if (error) throw error;\n        // Add vocabulary count to each group\n        const groupsWithCount = (data === null || data === void 0 ? void 0 : data.map((group)=>{\n            var _group_vocabulary_group_items_, _group_vocabulary_group_items;\n            return {\n                ...group,\n                vocabulary_count: ((_group_vocabulary_group_items = group.vocabulary_group_items) === null || _group_vocabulary_group_items === void 0 ? void 0 : (_group_vocabulary_group_items_ = _group_vocabulary_group_items[0]) === null || _group_vocabulary_group_items_ === void 0 ? void 0 : _group_vocabulary_group_items_.count) || 0\n            };\n        })) || [];\n        return groupsWithCount;\n    },\n    // Get single vocabulary group by ID\n    async getVocabularyGroup (id) {\n        const { data, error } = await supabase.from(\"vocabulary_groups\").select(\"\\n        *,\\n        category:categories(id, name, color, icon),\\n        vocabulary_group_items(\\n          *,\\n          vocabulary(*)\\n        )\\n      \").eq(\"id\", id).single();\n        if (error) throw error;\n        return data;\n    },\n    // Create new vocabulary group\n    async createVocabularyGroup (groupData) {\n        const { data: user } = await supabase.auth.getUser();\n        if (!user.user) throw new Error(\"User not authenticated\");\n        const dataWithDefaults = {\n            ...groupData,\n            language: groupData.language || \"en\",\n            difficulty: groupData.difficulty || \"beginner\",\n            is_public: groupData.is_public || false,\n            user_id: user.user.id\n        };\n        const { data, error } = await supabase.from(\"vocabulary_groups\").insert(dataWithDefaults).select().single();\n        if (error) throw error;\n        return data;\n    },\n    // Update vocabulary group\n    async updateVocabularyGroup (param) {\n        let { id, ...groupData } = param;\n        const { data, error } = await supabase.from(\"vocabulary_groups\").update({\n            ...groupData,\n            updated_at: new Date().toISOString()\n        }).eq(\"id\", id).select().single();\n        if (error) throw error;\n        return data;\n    },\n    // Delete vocabulary group\n    async deleteVocabularyGroup (id) {\n        const { error } = await supabase.from(\"vocabulary_groups\").delete().eq(\"id\", id);\n        if (error) throw error;\n    },\n    // ==================== GROUP MEMBERSHIP ====================\n    // Add vocabulary item to group\n    async addVocabularyToGroup (vocabularyId, groupId, position) {\n        // Get current max position if not provided\n        if (position === undefined) {\n            const { data: items } = await supabase.from(\"vocabulary_group_items\").select(\"position\").eq(\"vocabulary_group_id\", groupId).order(\"position\", {\n                ascending: false\n            }).limit(1);\n            position = items && items.length > 0 ? items[0].position + 1 : 0;\n        }\n        const { data, error } = await supabase.from(\"vocabulary_group_items\").insert({\n            vocabulary_group_id: groupId,\n            vocabulary_id: vocabularyId,\n            position: position\n        }).select().single();\n        if (error) throw error;\n        return data;\n    },\n    // Remove vocabulary item from group\n    async removeVocabularyFromGroup (vocabularyId, groupId) {\n        const { error } = await supabase.from(\"vocabulary_group_items\").delete().eq(\"vocabulary_group_id\", groupId).eq(\"vocabulary_id\", vocabularyId);\n        if (error) throw error;\n    },\n    // Update vocabulary position in group\n    async updateVocabularyPosition (vocabularyId, groupId, newPosition) {\n        const { data, error } = await supabase.from(\"vocabulary_group_items\").update({\n            position: newPosition\n        }).eq(\"vocabulary_group_id\", groupId).eq(\"vocabulary_id\", vocabularyId).select().single();\n        if (error) throw error;\n        return data;\n    },\n    // ==================== STATISTICS ====================\n    // Get vocabulary statistics\n    async getVocabularyStats () {\n        var _vocabularyData_data, _vocabularyData_data1, _vocabularyData_data2, _vocabularyData_data3, _vocabularyData_data4, _groupsData_data, _groupsData_data1, _groupsData_data2, _groupsData_data3, _groupsData_data4;\n        const { data: user } = await supabase.auth.getUser();\n        if (!user.user) throw new Error(\"User not authenticated\");\n        const [vocabularyData, groupsData] = await Promise.all([\n            supabase.from(\"vocabulary\").select(\"difficulty\", {\n                count: \"exact\"\n            }).eq(\"user_id\", user.user.id),\n            supabase.from(\"vocabulary_groups\").select(\"difficulty\", {\n                count: \"exact\"\n            }).eq(\"user_id\", user.user.id)\n        ]);\n        if (vocabularyData.error) throw vocabularyData.error;\n        if (groupsData.error) throw groupsData.error;\n        const vocabularyStats = {\n            total: ((_vocabularyData_data = vocabularyData.data) === null || _vocabularyData_data === void 0 ? void 0 : _vocabularyData_data.length) || 0,\n            beginner: ((_vocabularyData_data1 = vocabularyData.data) === null || _vocabularyData_data1 === void 0 ? void 0 : _vocabularyData_data1.filter((v)=>v.difficulty === \"beginner\").length) || 0,\n            intermediate: ((_vocabularyData_data2 = vocabularyData.data) === null || _vocabularyData_data2 === void 0 ? void 0 : _vocabularyData_data2.filter((v)=>v.difficulty === \"intermediate\").length) || 0,\n            advanced: ((_vocabularyData_data3 = vocabularyData.data) === null || _vocabularyData_data3 === void 0 ? void 0 : _vocabularyData_data3.filter((v)=>v.difficulty === \"advanced\").length) || 0,\n            expert: ((_vocabularyData_data4 = vocabularyData.data) === null || _vocabularyData_data4 === void 0 ? void 0 : _vocabularyData_data4.filter((v)=>v.difficulty === \"expert\").length) || 0\n        };\n        const groupStats = {\n            total: ((_groupsData_data = groupsData.data) === null || _groupsData_data === void 0 ? void 0 : _groupsData_data.length) || 0,\n            beginner: ((_groupsData_data1 = groupsData.data) === null || _groupsData_data1 === void 0 ? void 0 : _groupsData_data1.filter((g)=>g.difficulty === \"beginner\").length) || 0,\n            intermediate: ((_groupsData_data2 = groupsData.data) === null || _groupsData_data2 === void 0 ? void 0 : _groupsData_data2.filter((g)=>g.difficulty === \"intermediate\").length) || 0,\n            advanced: ((_groupsData_data3 = groupsData.data) === null || _groupsData_data3 === void 0 ? void 0 : _groupsData_data3.filter((g)=>g.difficulty === \"advanced\").length) || 0,\n            expert: ((_groupsData_data4 = groupsData.data) === null || _groupsData_data4 === void 0 ? void 0 : _groupsData_data4.filter((g)=>g.difficulty === \"expert\").length) || 0\n        };\n        return {\n            vocabulary: vocabularyStats,\n            groups: groupStats\n        };\n    },\n    // Get unique part of speech values\n    async getPartsOfSpeech () {\n        const { data: user } = await supabase.auth.getUser();\n        if (!user.user) throw new Error(\"User not authenticated\");\n        const { data, error } = await supabase.from(\"vocabulary\").select(\"part_of_speech\").eq(\"user_id\", user.user.id).not(\"part_of_speech\", \"is\", null);\n        if (error) throw error;\n        // Extract unique parts of speech\n        const partsOfSpeechSet = new Set(data === null || data === void 0 ? void 0 : data.map((vocab)=>vocab.part_of_speech).filter(Boolean));\n        const partsOfSpeech = Array.from(partsOfSpeechSet).sort();\n        return partsOfSpeech;\n    },\n    // Get unique languages used in vocabulary groups\n    async getLanguages () {\n        const { data: user } = await supabase.auth.getUser();\n        if (!user.user) throw new Error(\"User not authenticated\");\n        const { data, error } = await supabase.from(\"vocabulary_groups\").select(\"language, target_language\").eq(\"user_id\", user.user.id);\n        if (error) throw error;\n        // Extract unique languages\n        const languages = new Set();\n        data === null || data === void 0 ? void 0 : data.forEach((group)=>{\n            if (group.language) languages.add(group.language);\n            if (group.target_language) languages.add(group.target_language);\n        });\n        return Array.from(languages).sort();\n    },\n    // Get difficulty level options\n    getDifficultyLevels () {\n        return [\n            {\n                value: \"beginner\",\n                label: \"Beginner\",\n                color: \"green\"\n            },\n            {\n                value: \"intermediate\",\n                label: \"Intermediate\",\n                color: \"yellow\"\n            },\n            {\n                value: \"advanced\",\n                label: \"Advanced\",\n                color: \"orange\"\n            },\n            {\n                value: \"expert\",\n                label: \"Expert\",\n                color: \"red\"\n            }\n        ];\n    },\n    // Get common parts of speech options\n    getPartsOfSpeechOptions () {\n        return [\n            {\n                value: \"noun\",\n                label: \"Noun\"\n            },\n            {\n                value: \"verb\",\n                label: \"Verb\"\n            },\n            {\n                value: \"adjective\",\n                label: \"Adjective\"\n            },\n            {\n                value: \"adverb\",\n                label: \"Adverb\"\n            },\n            {\n                value: \"pronoun\",\n                label: \"Pronoun\"\n            },\n            {\n                value: \"preposition\",\n                label: \"Preposition\"\n            },\n            {\n                value: \"conjunction\",\n                label: \"Conjunction\"\n            },\n            {\n                value: \"interjection\",\n                label: \"Interjection\"\n            },\n            {\n                value: \"article\",\n                label: \"Article\"\n            }\n        ];\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc3VwYWJhc2Uvdm9jYWJ1bGFyeS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEU7QUFHNUUsTUFBTUMsV0FBV0QsMEZBQTJCQTtBQXNEckMsTUFBTUUsb0JBQW9CO0lBQy9CLDZEQUE2RDtJQUU3RCxpREFBaUQ7SUFDakQsTUFBTUM7WUFBY0MsVUFBQUEsaUVBQTZCLENBQUM7UUFDaEQsSUFBSUMsUUFBUUosU0FDVEssSUFBSSxDQUFDLGNBQ0xDLE1BQU0sQ0FBQyxLQUNQQyxLQUFLLENBQUMsUUFBUTtZQUFFQyxXQUFXO1FBQUs7UUFFbkMsZ0JBQWdCO1FBQ2hCLElBQUlMLFFBQVFNLE1BQU0sRUFBRTtZQUNsQkwsUUFBUUEsTUFBTU0sRUFBRSxDQUFDLGVBQXFEUCxPQUF0Q0EsUUFBUU0sTUFBTSxFQUFDLHlCQUE0RE4sT0FBckNBLFFBQVFNLE1BQU0sRUFBQyx3QkFBcUMsT0FBZk4sUUFBUU0sTUFBTSxFQUFDO1FBQzVIO1FBRUEsSUFBSU4sUUFBUVEsVUFBVSxFQUFFO1lBQ3RCUCxRQUFRQSxNQUFNUSxFQUFFLENBQUMsY0FBY1QsUUFBUVEsVUFBVTtRQUNuRDtRQUVBLElBQUlSLFFBQVFVLFlBQVksRUFBRTtZQUN4QlQsUUFBUUEsTUFBTVEsRUFBRSxDQUFDLGtCQUFrQlQsUUFBUVUsWUFBWTtRQUN6RDtRQUVBLElBQUlWLFFBQVFXLElBQUksSUFBSVgsUUFBUVcsSUFBSSxDQUFDQyxNQUFNLEdBQUcsR0FBRztZQUMzQ1gsUUFBUUEsTUFBTVksUUFBUSxDQUFDLFFBQVFiLFFBQVFXLElBQUk7UUFDN0M7UUFFQSxNQUFNLEVBQUVHLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTWQ7UUFFOUIsSUFBSWMsT0FBTyxNQUFNQTtRQUNqQixPQUFPRDtJQUNUO0lBRUEsMkNBQTJDO0lBQzNDLE1BQU1FLHNCQUFxQkMsT0FBZTtRQUN4QyxNQUFNLEVBQUVILElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcs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WUFDWixJQUFJQSxNQUFNUCxRQUFRLEVBQUVzRCxVQUFVRSxHQUFHLENBQUNqRCxNQUFNUCxRQUFRO1lBQ2hELElBQUlPLE1BQU1rRCxlQUFlLEVBQUVILFVBQVVFLEdBQUcsQ0FBQ2pELE1BQU1rRCxlQUFlO1FBQ2hFO1FBRUEsT0FBT04sTUFBTXZGLElBQUksQ0FBQzBGLFdBQVdGLElBQUk7SUFDbkM7SUFFQSwrQkFBK0I7SUFDL0JNO1FBQ0UsT0FBTztZQUNMO2dCQUFFQyxPQUFPO2dCQUFZQyxPQUFPO2dCQUFZQyxPQUFPO1lBQVE7WUFDdkQ7Z0JBQUVGLE9BQU87Z0JBQWdCQyxPQUFPO2dCQUFnQkMsT0FBTztZQUFTO1lBQ2hFO2dCQUFFRixPQUFPO2dCQUFZQyxPQUFPO2dCQUFZQyxPQUFPO1lBQVM7WUFDeEQ7Z0JBQUVGLE9BQU87Z0JBQVVDLE9BQU87Z0JBQVVDLE9BQU87WUFBTTtTQUNsRDtJQUNIO0lBRUEscUNBQXFDO0lBQ3JDQztRQUNFLE9BQU87WUFDTDtnQkFBRUgsT0FBTztnQkFBUUMsT0FBTztZQUFPO1lBQy9CO2dCQUFFRCxPQUFPO2dCQUFRQyxPQUFPO1lBQU87WUFDL0I7Z0JBQUVELE9BQU87Z0JBQWFDLE9BQU87WUFBWTtZQUN6QztnQkFBRUQsT0FBTztnQkFBVUMsT0FBTztZQUFTO1lBQ25DO2dCQUFFRCxPQUFPO2dCQUFXQyxPQUFPO1lBQVU7WUFDckM7Z0JBQUVELE9BQU87Z0JBQWVDLE9BQU87WUFBYztZQUM3QztnQkFBRUQsT0FBTztnQkFBZUMsT0FBTztZQUFjO1lBQzdDO2dCQUFFRCxPQUFPO2dCQUFnQkMsT0FBTztZQUFlO1lBQy9DO2dCQUFFRCxPQUFPO2dCQUFXQyxPQUFPO1lBQVU7U0FDdEM7SUFDSDtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9zdXBhYmFzZS92b2NhYnVsYXJ5LnRzPzFkOTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ2xpZW50Q29tcG9uZW50Q2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtaGVscGVycy1uZXh0anMnO1xuaW1wb3J0IHsgVm9jYWJ1bGFyeSwgVm9jYWJ1bGFyeUdyb3VwLCBWb2NhYnVsYXJ5R3JvdXBJdGVtLCBEaWZmaWN1bHR5TGV2ZWwgfSBmcm9tICdAL3R5cGVzL2RhdGFiYXNlJztcblxuY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnRDb21wb25lbnRDbGllbnQoKTtcblxuZXhwb3J0IGludGVyZmFjZSBWb2NhYnVsYXJ5RmlsdGVycyB7XG4gIHNlYXJjaD86IHN0cmluZztcbiAgZGlmZmljdWx0eT86IERpZmZpY3VsdHlMZXZlbDtcbiAgcGFydE9mU3BlZWNoPzogc3RyaW5nO1xuICB0YWdzPzogc3RyaW5nW107XG4gIGdyb3VwSWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVm9jYWJ1bGFyeUdyb3VwRmlsdGVycyB7XG4gIHNlYXJjaD86IHN0cmluZztcbiAgZGlmZmljdWx0eT86IERpZmZpY3VsdHlMZXZlbDtcbiAgbGFuZ3VhZ2U/OiBzdHJpbmc7XG4gIHRhcmdldExhbmd1YWdlPzogc3RyaW5nO1xuICBjYXRlZ29yeUlkPzogc3RyaW5nO1xuICB0YWdzPzogc3RyaW5nW107XG4gIGlzUHVibGljPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVWb2NhYnVsYXJ5RGF0YSB7XG4gIHdvcmQ6IHN0cmluZztcbiAgdHJhbnNsYXRpb24/OiBzdHJpbmc7XG4gIHByb251bmNpYXRpb24/OiBzdHJpbmc7XG4gIHBhcnRfb2Zfc3BlZWNoPzogc3RyaW5nO1xuICBkZWZpbml0aW9uPzogc3RyaW5nO1xuICBleGFtcGxlX3NlbnRlbmNlPzogc3RyaW5nO1xuICBleGFtcGxlX3RyYW5zbGF0aW9uPzogc3RyaW5nO1xuICBub3Rlcz86IHN0cmluZztcbiAgZGlmZmljdWx0eTogRGlmZmljdWx0eUxldmVsO1xuICBhdWRpb191cmw/OiBzdHJpbmc7XG4gIGltYWdlX3VybD86IHN0cmluZztcbiAgdGFncz86IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZVZvY2FidWxhcnlEYXRhIGV4dGVuZHMgUGFydGlhbDxDcmVhdGVWb2NhYnVsYXJ5RGF0YT4ge1xuICBpZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZVZvY2FidWxhcnlHcm91cERhdGEge1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBjYXRlZ29yeV9pZD86IHN0cmluZztcbiAgbGFuZ3VhZ2U6IHN0cmluZztcbiAgdGFyZ2V0X2xhbmd1YWdlPzogc3RyaW5nO1xuICBkaWZmaWN1bHR5OiBEaWZmaWN1bHR5TGV2ZWw7XG4gIHRhZ3M/OiBzdHJpbmdbXTtcbiAgaXNfcHVibGljPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVWb2NhYnVsYXJ5R3JvdXBEYXRhIGV4dGVuZHMgUGFydGlhbDxDcmVhdGVWb2NhYnVsYXJ5R3JvdXBEYXRhPiB7XG4gIGlkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCB2b2NhYnVsYXJ5U2VydmljZSA9IHtcbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gVk9DQUJVTEFSWSBJVEVNUyA9PT09PT09PT09PT09PT09PT09PVxuICBcbiAgLy8gR2V0IGFsbCB2b2NhYnVsYXJ5IGl0ZW1zIHdpdGggb3B0aW9uYWwgZmlsdGVyc1xuICBhc3luYyBnZXRWb2NhYnVsYXJ5KGZpbHRlcnM6IFZvY2FidWxhcnlGaWx0ZXJzID0ge30pIHtcbiAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3ZvY2FidWxhcnknKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAub3JkZXIoJ3dvcmQnLCB7IGFzY2VuZGluZzogdHJ1ZSB9KTtcblxuICAgIC8vIEFwcGx5IGZpbHRlcnNcbiAgICBpZiAoZmlsdGVycy5zZWFyY2gpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkub3IoYHdvcmQuaWxpa2UuJSR7ZmlsdGVycy5zZWFyY2h9JSx0cmFuc2xhdGlvbi5pbGlrZS4lJHtmaWx0ZXJzLnNlYXJjaH0lLGRlZmluaXRpb24uaWxpa2UuJSR7ZmlsdGVycy5zZWFyY2h9JWApO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZmlsdGVycy5kaWZmaWN1bHR5KSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdkaWZmaWN1bHR5JywgZmlsdGVycy5kaWZmaWN1bHR5KTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGZpbHRlcnMucGFydE9mU3BlZWNoKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdwYXJ0X29mX3NwZWVjaCcsIGZpbHRlcnMucGFydE9mU3BlZWNoKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGZpbHRlcnMudGFncyAmJiBmaWx0ZXJzLnRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5jb250YWlucygndGFncycsIGZpbHRlcnMudGFncyk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICByZXR1cm4gZGF0YSBhcyBWb2NhYnVsYXJ5W107XG4gIH0sXG5cbiAgLy8gR2V0IHZvY2FidWxhcnkgaXRlbXMgaW4gYSBzcGVjaWZpYyBncm91cFxuICBhc3luYyBnZXRWb2NhYnVsYXJ5SW5Hcm91cChncm91cElkOiBzdHJpbmcpIHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3ZvY2FidWxhcnlfZ3JvdXBfaXRlbXMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgICosXG4gICAgICAgIHZvY2FidWxhcnkoKilcbiAgICAgIGApXG4gICAgICAuZXEoJ3ZvY2FidWxhcnlfZ3JvdXBfaWQnLCBncm91cElkKVxuICAgICAgLm9yZGVyKCdwb3NpdGlvbicsIHsgYXNjZW5kaW5nOiB0cnVlIH0pO1xuICAgIFxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgcmV0dXJuIGRhdGEgYXMgKFZvY2FidWxhcnlHcm91cEl0ZW0gJiB7IHZvY2FidWxhcnk6IFZvY2FidWxhcnkgfSlbXTtcbiAgfSxcblxuICAvLyBHZXQgc2luZ2xlIHZvY2FidWxhcnkgaXRlbSBieSBJRFxuICBhc3luYyBnZXRWb2NhYnVsYXJ5SXRlbShpZDogc3RyaW5nKSB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd2b2NhYnVsYXJ5JylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgLnNpbmdsZSgpO1xuICAgIFxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgcmV0dXJuIGRhdGEgYXMgVm9jYWJ1bGFyeTtcbiAgfSxcblxuICAvLyBDcmVhdGUgbmV3IHZvY2FidWxhcnkgaXRlbVxuICBhc3luYyBjcmVhdGVWb2NhYnVsYXJ5KHZvY2FidWxhcnlEYXRhOiBDcmVhdGVWb2NhYnVsYXJ5RGF0YSkge1xuICAgIGNvbnN0IHsgZGF0YTogdXNlciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gICAgaWYgKCF1c2VyLnVzZXIpIHRocm93IG5ldyBFcnJvcignVXNlciBub3QgYXV0aGVudGljYXRlZCcpO1xuXG4gICAgY29uc3QgZGF0YVdpdGhEZWZhdWx0cyA9IHtcbiAgICAgIC4uLnZvY2FidWxhcnlEYXRhLFxuICAgICAgZGlmZmljdWx0eTogdm9jYWJ1bGFyeURhdGEuZGlmZmljdWx0eSB8fCAnYmVnaW5uZXInIGFzIERpZmZpY3VsdHlMZXZlbCxcbiAgICAgIHVzZXJfaWQ6IHVzZXIudXNlci5pZCxcbiAgICB9O1xuXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd2b2NhYnVsYXJ5JylcbiAgICAgIC5pbnNlcnQoZGF0YVdpdGhEZWZhdWx0cylcbiAgICAgIC5zZWxlY3QoKVxuICAgICAgLnNpbmdsZSgpO1xuICAgIFxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgcmV0dXJuIGRhdGEgYXMgVm9jYWJ1bGFyeTtcbiAgfSxcblxuICAvLyBVcGRhdGUgdm9jYWJ1bGFyeSBpdGVtXG4gIGFzeW5jIHVwZGF0ZVZvY2FidWxhcnkoeyBpZCwgLi4udm9jYWJ1bGFyeURhdGEgfTogVXBkYXRlVm9jYWJ1bGFyeURhdGEpIHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3ZvY2FidWxhcnknKVxuICAgICAgLnVwZGF0ZSh7XG4gICAgICAgIC4uLnZvY2FidWxhcnlEYXRhLFxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9KVxuICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgLnNlbGVjdCgpXG4gICAgICAuc2luZ2xlKCk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICByZXR1cm4gZGF0YSBhcyBWb2NhYnVsYXJ5O1xuICB9LFxuXG4gIC8vIERlbGV0ZSB2b2NhYnVsYXJ5IGl0ZW1cbiAgYXN5bmMgZGVsZXRlVm9jYWJ1bGFyeShpZDogc3RyaW5nKSB7XG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd2b2NhYnVsYXJ5JylcbiAgICAgIC5kZWxldGUoKVxuICAgICAgLmVxKCdpZCcsIGlkKTtcbiAgICBcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09IFZPQ0FCVUxBUlkgR1JPVVBTID09PT09PT09PT09PT09PT09PT09XG4gIFxuICAvLyBHZXQgYWxsIHZvY2FidWxhcnkgZ3JvdXBzIHdpdGggb3B0aW9uYWwgZmlsdGVyc1xuICBhc3luYyBnZXRWb2NhYnVsYXJ5R3JvdXBzKGZpbHRlcnM6IFZvY2FidWxhcnlHcm91cEZpbHRlcnMgPSB7fSkge1xuICAgIGxldCBxdWVyeSA9IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndm9jYWJ1bGFyeV9ncm91cHMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgICosXG4gICAgICAgIGNhdGVnb3J5OmNhdGVnb3JpZXMoaWQsIG5hbWUsIGNvbG9yLCBpY29uKSxcbiAgICAgICAgdm9jYWJ1bGFyeV9ncm91cF9pdGVtcyhjb3VudCksXG4gICAgICAgIHZvY2FidWxhcnlfZ3JvdXBfYm9va3MoXG4gICAgICAgICAgYm9vazpib29rcyhcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICBhdXRob3IsXG4gICAgICAgICAgICBjb3Zlcl9pbWFnZV91cmxcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIGApXG4gICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG5cbiAgICAvLyBBcHBseSBmaWx0ZXJzXG4gICAgaWYgKGZpbHRlcnMuc2VhcmNoKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5Lm9yKGBuYW1lLmlsaWtlLiUke2ZpbHRlcnMuc2VhcmNofSUsZGVzY3JpcHRpb24uaWxpa2UuJSR7ZmlsdGVycy5zZWFyY2h9JWApO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZmlsdGVycy5kaWZmaWN1bHR5KSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdkaWZmaWN1bHR5JywgZmlsdGVycy5kaWZmaWN1bHR5KTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGZpbHRlcnMubGFuZ3VhZ2UpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ2xhbmd1YWdlJywgZmlsdGVycy5sYW5ndWFnZSk7XG4gICAgfVxuICAgIFxuICAgIGlmIChmaWx0ZXJzLnRhcmdldExhbmd1YWdlKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCd0YXJnZXRfbGFuZ3VhZ2UnLCBmaWx0ZXJzLnRhcmdldExhbmd1YWdlKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGZpbHRlcnMuY2F0ZWdvcnlJZCkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnY2F0ZWdvcnlfaWQnLCBmaWx0ZXJzLmNhdGVnb3J5SWQpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZmlsdGVycy5pc1B1YmxpYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdpc19wdWJsaWMnLCBmaWx0ZXJzLmlzUHVibGljKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGZpbHRlcnMudGFncyAmJiBmaWx0ZXJzLnRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5jb250YWlucygndGFncycsIGZpbHRlcnMudGFncyk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgcXVlcnk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICBcbiAgICAvLyBBZGQgdm9jYWJ1bGFyeSBjb3VudCB0byBlYWNoIGdyb3VwXG4gICAgY29uc3QgZ3JvdXBzV2l0aENvdW50ID0gZGF0YT8ubWFwKGdyb3VwID0+ICh7XG4gICAgICAuLi5ncm91cCxcbiAgICAgIHZvY2FidWxhcnlfY291bnQ6IGdyb3VwLnZvY2FidWxhcnlfZ3JvdXBfaXRlbXM/LlswXT8uY291bnQgfHwgMFxuICAgIH0pKSB8fCBbXTtcbiAgICBcbiAgICByZXR1cm4gZ3JvdXBzV2l0aENvdW50IGFzIChWb2NhYnVsYXJ5R3JvdXAgJiB7IHZvY2FidWxhcnlfY291bnQ6IG51bWJlciB9KVtdO1xuICB9LFxuXG4gIC8vIEdldCBzaW5nbGUgdm9jYWJ1bGFyeSBncm91cCBieSBJRFxuICBhc3luYyBnZXRWb2NhYnVsYXJ5R3JvdXAoaWQ6IHN0cmluZykge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndm9jYWJ1bGFyeV9ncm91cHMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgICosXG4gICAgICAgIGNhdGVnb3J5OmNhdGVnb3JpZXMoaWQsIG5hbWUsIGNvbG9yLCBpY29uKSxcbiAgICAgICAgdm9jYWJ1bGFyeV9ncm91cF9pdGVtcyhcbiAgICAgICAgICAqLFxuICAgICAgICAgIHZvY2FidWxhcnkoKilcbiAgICAgICAgKVxuICAgICAgYClcbiAgICAgIC5lcSgnaWQnLCBpZClcbiAgICAgIC5zaW5nbGUoKTtcbiAgICBcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICAgIHJldHVybiBkYXRhIGFzIFZvY2FidWxhcnlHcm91cCAmIHsgdm9jYWJ1bGFyeV9ncm91cF9pdGVtczogKFZvY2FidWxhcnlHcm91cEl0ZW0gJiB7IHZvY2FidWxhcnk6IFZvY2FidWxhcnkgfSlbXSB9O1xuICB9LFxuXG4gIC8vIENyZWF0ZSBuZXcgdm9jYWJ1bGFyeSBncm91cFxuICBhc3luYyBjcmVhdGVWb2NhYnVsYXJ5R3JvdXAoZ3JvdXBEYXRhOiBDcmVhdGVWb2NhYnVsYXJ5R3JvdXBEYXRhKSB7XG4gICAgY29uc3QgeyBkYXRhOiB1c2VyIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICBpZiAoIXVzZXIudXNlcikgdGhyb3cgbmV3IEVycm9yKCdVc2VyIG5vdCBhdXRoZW50aWNhdGVkJyk7XG5cbiAgICBjb25zdCBkYXRhV2l0aERlZmF1bHRzID0ge1xuICAgICAgLi4uZ3JvdXBEYXRhLFxuICAgICAgbGFuZ3VhZ2U6IGdyb3VwRGF0YS5sYW5ndWFnZSB8fCAnZW4nLFxuICAgICAgZGlmZmljdWx0eTogZ3JvdXBEYXRhLmRpZmZpY3VsdHkgfHwgJ2JlZ2lubmVyJyBhcyBEaWZmaWN1bHR5TGV2ZWwsXG4gICAgICBpc19wdWJsaWM6IGdyb3VwRGF0YS5pc19wdWJsaWMgfHwgZmFsc2UsXG4gICAgICB1c2VyX2lkOiB1c2VyLnVzZXIuaWQsXG4gICAgfTtcblxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndm9jYWJ1bGFyeV9ncm91cHMnKVxuICAgICAgLmluc2VydChkYXRhV2l0aERlZmF1bHRzKVxuICAgICAgLnNlbGVjdCgpXG4gICAgICAuc2luZ2xlKCk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICByZXR1cm4gZGF0YSBhcyBWb2NhYnVsYXJ5R3JvdXA7XG4gIH0sXG5cbiAgLy8gVXBkYXRlIHZvY2FidWxhcnkgZ3JvdXBcbiAgYXN5bmMgdXBkYXRlVm9jYWJ1bGFyeUdyb3VwKHsgaWQsIC4uLmdyb3VwRGF0YSB9OiBVcGRhdGVWb2NhYnVsYXJ5R3JvdXBEYXRhKSB7XG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd2b2NhYnVsYXJ5X2dyb3VwcycpXG4gICAgICAudXBkYXRlKHtcbiAgICAgICAgLi4uZ3JvdXBEYXRhLFxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9KVxuICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgLnNlbGVjdCgpXG4gICAgICAuc2luZ2xlKCk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICByZXR1cm4gZGF0YSBhcyBWb2NhYnVsYXJ5R3JvdXA7XG4gIH0sXG5cbiAgLy8gRGVsZXRlIHZvY2FidWxhcnkgZ3JvdXBcbiAgYXN5bmMgZGVsZXRlVm9jYWJ1bGFyeUdyb3VwKGlkOiBzdHJpbmcpIHtcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3ZvY2FidWxhcnlfZ3JvdXBzJylcbiAgICAgIC5kZWxldGUoKVxuICAgICAgLmVxKCdpZCcsIGlkKTtcbiAgICBcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09IEdST1VQIE1FTUJFUlNISVAgPT09PT09PT09PT09PT09PT09PT1cbiAgXG4gIC8vIEFkZCB2b2NhYnVsYXJ5IGl0ZW0gdG8gZ3JvdXBcbiAgYXN5bmMgYWRkVm9jYWJ1bGFyeVRvR3JvdXAodm9jYWJ1bGFyeUlkOiBzdHJpbmcsIGdyb3VwSWQ6IHN0cmluZywgcG9zaXRpb24/OiBudW1iZXIpIHtcbiAgICAvLyBHZXQgY3VycmVudCBtYXggcG9zaXRpb24gaWYgbm90IHByb3ZpZGVkXG4gICAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHsgZGF0YTogaXRlbXMgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd2b2NhYnVsYXJ5X2dyb3VwX2l0ZW1zJylcbiAgICAgICAgLnNlbGVjdCgncG9zaXRpb24nKVxuICAgICAgICAuZXEoJ3ZvY2FidWxhcnlfZ3JvdXBfaWQnLCBncm91cElkKVxuICAgICAgICAub3JkZXIoJ3Bvc2l0aW9uJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgICAgIC5saW1pdCgxKTtcbiAgICAgIFxuICAgICAgcG9zaXRpb24gPSBpdGVtcyAmJiBpdGVtcy5sZW5ndGggPiAwID8gaXRlbXNbMF0ucG9zaXRpb24gKyAxIDogMDtcbiAgICB9XG5cbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3ZvY2FidWxhcnlfZ3JvdXBfaXRlbXMnKVxuICAgICAgLmluc2VydCh7XG4gICAgICAgIHZvY2FidWxhcnlfZ3JvdXBfaWQ6IGdyb3VwSWQsXG4gICAgICAgIHZvY2FidWxhcnlfaWQ6IHZvY2FidWxhcnlJZCxcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgfSlcbiAgICAgIC5zZWxlY3QoKVxuICAgICAgLnNpbmdsZSgpO1xuICAgIFxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgcmV0dXJuIGRhdGEgYXMgVm9jYWJ1bGFyeUdyb3VwSXRlbTtcbiAgfSxcblxuICAvLyBSZW1vdmUgdm9jYWJ1bGFyeSBpdGVtIGZyb20gZ3JvdXBcbiAgYXN5bmMgcmVtb3ZlVm9jYWJ1bGFyeUZyb21Hcm91cCh2b2NhYnVsYXJ5SWQ6IHN0cmluZywgZ3JvdXBJZDogc3RyaW5nKSB7XG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd2b2NhYnVsYXJ5X2dyb3VwX2l0ZW1zJylcbiAgICAgIC5kZWxldGUoKVxuICAgICAgLmVxKCd2b2NhYnVsYXJ5X2dyb3VwX2lkJywgZ3JvdXBJZClcbiAgICAgIC5lcSgndm9jYWJ1bGFyeV9pZCcsIHZvY2FidWxhcnlJZCk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgfSxcblxuICAvLyBVcGRhdGUgdm9jYWJ1bGFyeSBwb3NpdGlvbiBpbiBncm91cFxuICBhc3luYyB1cGRhdGVWb2NhYnVsYXJ5UG9zaXRpb24odm9jYWJ1bGFyeUlkOiBzdHJpbmcsIGdyb3VwSWQ6IHN0cmluZywgbmV3UG9zaXRpb246IG51bWJlcikge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndm9jYWJ1bGFyeV9ncm91cF9pdGVtcycpXG4gICAgICAudXBkYXRlKHsgcG9zaXRpb246IG5ld1Bvc2l0aW9uIH0pXG4gICAgICAuZXEoJ3ZvY2FidWxhcnlfZ3JvdXBfaWQnLCBncm91cElkKVxuICAgICAgLmVxKCd2b2NhYnVsYXJ5X2lkJywgdm9jYWJ1bGFyeUlkKVxuICAgICAgLnNlbGVjdCgpXG4gICAgICAuc2luZ2xlKCk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICByZXR1cm4gZGF0YSBhcyBWb2NhYnVsYXJ5R3JvdXBJdGVtO1xuICB9LFxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09IFNUQVRJU1RJQ1MgPT09PT09PT09PT09PT09PT09PT1cbiAgXG4gIC8vIEdldCB2b2NhYnVsYXJ5IHN0YXRpc3RpY3NcbiAgYXN5bmMgZ2V0Vm9jYWJ1bGFyeVN0YXRzKCkge1xuICAgIGNvbnN0IHsgZGF0YTogdXNlciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gICAgaWYgKCF1c2VyLnVzZXIpIHRocm93IG5ldyBFcnJvcignVXNlciBub3QgYXV0aGVudGljYXRlZCcpO1xuXG4gICAgY29uc3QgW3ZvY2FidWxhcnlEYXRhLCBncm91cHNEYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd2b2NhYnVsYXJ5JylcbiAgICAgICAgLnNlbGVjdCgnZGlmZmljdWx0eScsIHsgY291bnQ6ICdleGFjdCcgfSlcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci51c2VyLmlkKSxcbiAgICAgIHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd2b2NhYnVsYXJ5X2dyb3VwcycpXG4gICAgICAgIC5zZWxlY3QoJ2RpZmZpY3VsdHknLCB7IGNvdW50OiAnZXhhY3QnIH0pXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIudXNlci5pZCksXG4gICAgXSk7XG4gICAgXG4gICAgaWYgKHZvY2FidWxhcnlEYXRhLmVycm9yKSB0aHJvdyB2b2NhYnVsYXJ5RGF0YS5lcnJvcjtcbiAgICBpZiAoZ3JvdXBzRGF0YS5lcnJvcikgdGhyb3cgZ3JvdXBzRGF0YS5lcnJvcjtcblxuICAgIGNvbnN0IHZvY2FidWxhcnlTdGF0cyA9IHtcbiAgICAgIHRvdGFsOiB2b2NhYnVsYXJ5RGF0YS5kYXRhPy5sZW5ndGggfHwgMCxcbiAgICAgIGJlZ2lubmVyOiB2b2NhYnVsYXJ5RGF0YS5kYXRhPy5maWx0ZXIodiA9PiB2LmRpZmZpY3VsdHkgPT09ICdiZWdpbm5lcicpLmxlbmd0aCB8fCAwLFxuICAgICAgaW50ZXJtZWRpYXRlOiB2b2NhYnVsYXJ5RGF0YS5kYXRhPy5maWx0ZXIodiA9PiB2LmRpZmZpY3VsdHkgPT09ICdpbnRlcm1lZGlhdGUnKS5sZW5ndGggfHwgMCxcbiAgICAgIGFkdmFuY2VkOiB2b2NhYnVsYXJ5RGF0YS5kYXRhPy5maWx0ZXIodiA9PiB2LmRpZmZpY3VsdHkgPT09ICdhZHZhbmNlZCcpLmxlbmd0aCB8fCAwLFxuICAgICAgZXhwZXJ0OiB2b2NhYnVsYXJ5RGF0YS5kYXRhPy5maWx0ZXIodiA9PiB2LmRpZmZpY3VsdHkgPT09ICdleHBlcnQnKS5sZW5ndGggfHwgMCxcbiAgICB9O1xuXG4gICAgY29uc3QgZ3JvdXBTdGF0cyA9IHtcbiAgICAgIHRvdGFsOiBncm91cHNEYXRhLmRhdGE/Lmxlbmd0aCB8fCAwLFxuICAgICAgYmVnaW5uZXI6IGdyb3Vwc0RhdGEuZGF0YT8uZmlsdGVyKGcgPT4gZy5kaWZmaWN1bHR5ID09PSAnYmVnaW5uZXInKS5sZW5ndGggfHwgMCxcbiAgICAgIGludGVybWVkaWF0ZTogZ3JvdXBzRGF0YS5kYXRhPy5maWx0ZXIoZyA9PiBnLmRpZmZpY3VsdHkgPT09ICdpbnRlcm1lZGlhdGUnKS5sZW5ndGggfHwgMCxcbiAgICAgIGFkdmFuY2VkOiBncm91cHNEYXRhLmRhdGE/LmZpbHRlcihnID0+IGcuZGlmZmljdWx0eSA9PT0gJ2FkdmFuY2VkJykubGVuZ3RoIHx8IDAsXG4gICAgICBleHBlcnQ6IGdyb3Vwc0RhdGEuZGF0YT8uZmlsdGVyKGcgPT4gZy5kaWZmaWN1bHR5ID09PSAnZXhwZXJ0JykubGVuZ3RoIHx8IDAsXG4gICAgfTtcblxuICAgIHJldHVybiB7IHZvY2FidWxhcnk6IHZvY2FidWxhcnlTdGF0cywgZ3JvdXBzOiBncm91cFN0YXRzIH07XG4gIH0sXG5cbiAgLy8gR2V0IHVuaXF1ZSBwYXJ0IG9mIHNwZWVjaCB2YWx1ZXNcbiAgYXN5bmMgZ2V0UGFydHNPZlNwZWVjaCgpIHtcbiAgICBjb25zdCB7IGRhdGE6IHVzZXIgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICAgIGlmICghdXNlci51c2VyKSB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgbm90IGF1dGhlbnRpY2F0ZWQnKTtcblxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndm9jYWJ1bGFyeScpXG4gICAgICAuc2VsZWN0KCdwYXJ0X29mX3NwZWVjaCcpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLnVzZXIuaWQpXG4gICAgICAubm90KCdwYXJ0X29mX3NwZWVjaCcsICdpcycsIG51bGwpO1xuICAgIFxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG5cbiAgICAvLyBFeHRyYWN0IHVuaXF1ZSBwYXJ0cyBvZiBzcGVlY2hcbiAgICBjb25zdCBwYXJ0c09mU3BlZWNoU2V0ID0gbmV3IFNldChkYXRhPy5tYXAodm9jYWIgPT4gdm9jYWIucGFydF9vZl9zcGVlY2gpLmZpbHRlcihCb29sZWFuKSk7XG4gICAgY29uc3QgcGFydHNPZlNwZWVjaCA9IEFycmF5LmZyb20ocGFydHNPZlNwZWVjaFNldCkuc29ydCgpO1xuICAgIHJldHVybiBwYXJ0c09mU3BlZWNoO1xuICB9LFxuXG4gIC8vIEdldCB1bmlxdWUgbGFuZ3VhZ2VzIHVzZWQgaW4gdm9jYWJ1bGFyeSBncm91cHNcbiAgYXN5bmMgZ2V0TGFuZ3VhZ2VzKCkge1xuICAgIGNvbnN0IHsgZGF0YTogdXNlciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gICAgaWYgKCF1c2VyLnVzZXIpIHRocm93IG5ldyBFcnJvcignVXNlciBub3QgYXV0aGVudGljYXRlZCcpO1xuXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd2b2NhYnVsYXJ5X2dyb3VwcycpXG4gICAgICAuc2VsZWN0KCdsYW5ndWFnZSwgdGFyZ2V0X2xhbmd1YWdlJylcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIudXNlci5pZCk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcblxuICAgIC8vIEV4dHJhY3QgdW5pcXVlIGxhbmd1YWdlc1xuICAgIGNvbnN0IGxhbmd1YWdlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGRhdGE/LmZvckVhY2goZ3JvdXAgPT4ge1xuICAgICAgaWYgKGdyb3VwLmxhbmd1YWdlKSBsYW5ndWFnZXMuYWRkKGdyb3VwLmxhbmd1YWdlKTtcbiAgICAgIGlmIChncm91cC50YXJnZXRfbGFuZ3VhZ2UpIGxhbmd1YWdlcy5hZGQoZ3JvdXAudGFyZ2V0X2xhbmd1YWdlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBBcnJheS5mcm9tKGxhbmd1YWdlcykuc29ydCgpO1xuICB9LFxuXG4gIC8vIEdldCBkaWZmaWN1bHR5IGxldmVsIG9wdGlvbnNcbiAgZ2V0RGlmZmljdWx0eUxldmVscygpOiB7IHZhbHVlOiBEaWZmaWN1bHR5TGV2ZWw7IGxhYmVsOiBzdHJpbmc7IGNvbG9yOiBzdHJpbmcgfVtdIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB2YWx1ZTogJ2JlZ2lubmVyJywgbGFiZWw6ICdCZWdpbm5lcicsIGNvbG9yOiAnZ3JlZW4nIH0sXG4gICAgICB7IHZhbHVlOiAnaW50ZXJtZWRpYXRlJywgbGFiZWw6ICdJbnRlcm1lZGlhdGUnLCBjb2xvcjogJ3llbGxvdycgfSxcbiAgICAgIHsgdmFsdWU6ICdhZHZhbmNlZCcsIGxhYmVsOiAnQWR2YW5jZWQnLCBjb2xvcjogJ29yYW5nZScgfSxcbiAgICAgIHsgdmFsdWU6ICdleHBlcnQnLCBsYWJlbDogJ0V4cGVydCcsIGNvbG9yOiAncmVkJyB9LFxuICAgIF07XG4gIH0sXG5cbiAgLy8gR2V0IGNvbW1vbiBwYXJ0cyBvZiBzcGVlY2ggb3B0aW9uc1xuICBnZXRQYXJ0c09mU3BlZWNoT3B0aW9ucygpOiB7IHZhbHVlOiBzdHJpbmc7IGxhYmVsOiBzdHJpbmcgfVtdIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB2YWx1ZTogJ25vdW4nLCBsYWJlbDogJ05vdW4nIH0sXG4gICAgICB7IHZhbHVlOiAndmVyYicsIGxhYmVsOiAnVmVyYicgfSxcbiAgICAgIHsgdmFsdWU6ICdhZGplY3RpdmUnLCBsYWJlbDogJ0FkamVjdGl2ZScgfSxcbiAgICAgIHsgdmFsdWU6ICdhZHZlcmInLCBsYWJlbDogJ0FkdmVyYicgfSxcbiAgICAgIHsgdmFsdWU6ICdwcm9ub3VuJywgbGFiZWw6ICdQcm9ub3VuJyB9LFxuICAgICAgeyB2YWx1ZTogJ3ByZXBvc2l0aW9uJywgbGFiZWw6ICdQcmVwb3NpdGlvbicgfSxcbiAgICAgIHsgdmFsdWU6ICdjb25qdW5jdGlvbicsIGxhYmVsOiAnQ29uanVuY3Rpb24nIH0sXG4gICAgICB7IHZhbHVlOiAnaW50ZXJqZWN0aW9uJywgbGFiZWw6ICdJbnRlcmplY3Rpb24nIH0sXG4gICAgICB7IHZhbHVlOiAnYXJ0aWNsZScsIGxhYmVsOiAnQXJ0aWNsZScgfSxcbiAgICBdO1xuICB9LFxufTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnRDb21wb25lbnRDbGllbnQiLCJzdXBhYmFzZSIsInZvY2FidWxhcnlTZXJ2aWNlIiwiZ2V0Vm9jYWJ1bGFyeSIsImZpbHRlcnMiLCJxdWVyeSIsImZyb20iLCJzZWxlY3QiLCJvcmRlciIsImFzY2VuZGluZyIsInNlYXJjaCIsIm9yIiwiZGlmZmljdWx0eSIsImVxIiwicGFydE9mU3BlZWNoIiwidGFncyIsImxlbmd0aCIsImNvbnRhaW5zIiwiZGF0YSIsImVycm9yIiwiZ2V0Vm9jYWJ1bGFyeUluR3JvdXAiLCJncm91cElkIiwiZ2V0Vm9jYWJ1bGFyeUl0ZW0iLCJpZCIsInNpbmdsZSIsImNyZWF0ZVZvY2FidWxhcnkiLCJ2b2NhYnVsYXJ5RGF0YSIsInVzZXIiLCJhdXRoIiwiZ2V0VXNlciIsIkVycm9yIiwiZGF0YVdpdGhEZWZhdWx0cyIsInVzZXJfaWQiLCJpbnNlcnQiLCJ1cGRhdGVWb2NhYnVsYXJ5IiwidXBkYXRlIiwidXBkYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImRlbGV0ZVZvY2FidWxhcnkiLCJkZWxldGUiLCJnZXRWb2NhYnVsYXJ5R3JvdXBzIiwibGFuZ3VhZ2UiLCJ0YXJnZXRMYW5ndWFnZSIsImNhdGVnb3J5SWQiLCJpc1B1YmxpYyIsInVuZGVmaW5lZCIsImdyb3Vwc1dpdGhDb3VudCIsIm1hcCIsImdyb3VwIiwidm9jYWJ1bGFyeV9jb3VudCIsInZvY2FidWxhcnlfZ3JvdXBfaXRlbXMiLCJjb3VudCIsImdldFZvY2FidWxhcnlHcm91cCIsImNyZWF0ZVZvY2FidWxhcnlHcm91cCIsImdyb3VwRGF0YSIsImlzX3B1YmxpYyIsInVwZGF0ZVZvY2FidWxhcnlHcm91cCIsImRlbGV0ZVZvY2FidWxhcnlHcm91cCIsImFkZFZvY2FidWxhcnlUb0dyb3VwIiwidm9jYWJ1bGFyeUlkIiwicG9zaXRpb24iLCJpdGVtcyIsImxpbWl0Iiwidm9jYWJ1bGFyeV9ncm91cF9pZCIsInZvY2FidWxhcnlfaWQiLCJyZW1vdmVWb2NhYnVsYXJ5RnJvbUdyb3VwIiwidXBkYXRlVm9jYWJ1bGFyeVBvc2l0aW9uIiwibmV3UG9zaXRpb24iLCJnZXRWb2NhYnVsYXJ5U3RhdHMiLCJncm91cHNEYXRhIiwiUHJvbWlzZSIsImFsbCIsInZvY2FidWxhcnlTdGF0cyIsInRvdGFsIiwiYmVnaW5uZXIiLCJmaWx0ZXIiLCJ2IiwiaW50ZXJtZWRpYXRlIiwiYWR2YW5jZWQiLCJleHBlcnQiLCJncm91cFN0YXRzIiwiZyIsInZvY2FidWxhcnkiLCJncm91cHMiLCJnZXRQYXJ0c09mU3BlZWNoIiwibm90IiwicGFydHNPZlNwZWVjaFNldCIsIlNldCIsInZvY2FiIiwicGFydF9vZl9zcGVlY2giLCJCb29sZWFuIiwicGFydHNPZlNwZWVjaCIsIkFycmF5Iiwic29ydCIsImdldExhbmd1YWdlcyIsImxhbmd1YWdlcyIsImZvckVhY2giLCJhZGQiLCJ0YXJnZXRfbGFuZ3VhZ2UiLCJnZXREaWZmaWN1bHR5TGV2ZWxzIiwidmFsdWUiLCJsYWJlbCIsImNvbG9yIiwiZ2V0UGFydHNPZlNwZWVjaE9wdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/supabase/vocabulary.ts\n"));

/***/ })

});