"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/books/page",{

/***/ "(app-pages-browser)/./src/lib/supabase/books.ts":
/*!***********************************!*\
  !*** ./src/lib/supabase/books.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bookService: function() { return /* binding */ bookService; }\n/* harmony export */ });\n/* harmony import */ var _supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/auth-helpers-nextjs */ \"(app-pages-browser)/./node_modules/@supabase/auth-helpers-nextjs/dist/index.js\");\n/* harmony import */ var _supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_0__);\n\nconst supabase = (0,_supabase_auth_helpers_nextjs__WEBPACK_IMPORTED_MODULE_0__.createClientComponentClient)();\nconst bookService = {\n    // Get all books with optional filters\n    async getBooks () {\n        let filters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        let query = supabase.from(\"books\").select(\"\\n        *,\\n        category:categories(id, name, color, icon),\\n        vocabulary_group_books(\\n          vocabulary_group:vocabulary_groups(\\n            id,\\n            name,\\n            difficulty\\n          )\\n        )\\n      \").order(\"created_at\", {\n            ascending: false\n        });\n        // Apply filters\n        if (filters.search) {\n            query = query.or(\"title.ilike.%\".concat(filters.search, \"%,author.ilike.%\").concat(filters.search, \"%,description.ilike.%\").concat(filters.search, \"%\"));\n        }\n        if (filters.author) {\n            query = query.ilike(\"author\", \"%\".concat(filters.author, \"%\"));\n        }\n        if (filters.categoryId) {\n            query = query.eq(\"category_id\", filters.categoryId);\n        }\n        if (filters.contentType) {\n            query = query.eq(\"content_type\", filters.contentType);\n        }\n        if (filters.language) {\n            query = query.eq(\"language\", filters.language);\n        }\n        if (filters.publicationYear) {\n            query = query.eq(\"publication_year\", filters.publicationYear);\n        }\n        if (filters.isPublic !== undefined) {\n            query = query.eq(\"is_public\", filters.isPublic);\n        }\n        if (filters.tags && filters.tags.length > 0) {\n            query = query.contains(\"tags\", filters.tags);\n        }\n        const { data, error } = await query;\n        if (error) throw error;\n        return data;\n    },\n    // Get single book by ID\n    async getBook (id) {\n        const { data, error } = await supabase.from(\"books\").select(\"\\n        *,\\n        category:categories(id, name, color, icon),\\n        course_books(\\n          id,\\n          course_id,\\n          is_required,\\n          notes,\\n          position,\\n          course:courses(id, title, status)\\n        )\\n      \").eq(\"id\", id).single();\n        if (error) throw error;\n        return data;\n    },\n    // Create new book\n    async createBook (bookData) {\n        const { data: user } = await supabase.auth.getUser();\n        if (!user.user) throw new Error(\"User not authenticated\");\n        // Set default language if not provided\n        const dataWithDefaults = {\n            ...bookData,\n            language: bookData.language || \"en\",\n            is_public: bookData.is_public || false,\n            user_id: user.user.id\n        };\n        const { data, error } = await supabase.from(\"books\").insert(dataWithDefaults).select().single();\n        if (error) throw error;\n        return data;\n    },\n    // Update book\n    async updateBook (param) {\n        let { id, ...bookData } = param;\n        const { data, error } = await supabase.from(\"books\").update({\n            ...bookData,\n            updated_at: new Date().toISOString()\n        }).eq(\"id\", id).select().single();\n        if (error) throw error;\n        return data;\n    },\n    // Delete book\n    async deleteBook (id) {\n        const { error } = await supabase.from(\"books\").delete().eq(\"id\", id);\n        if (error) throw error;\n    },\n    // Get book statistics\n    async getBookStats () {\n        const { data: user } = await supabase.auth.getUser();\n        if (!user.user) throw new Error(\"User not authenticated\");\n        const { data, error } = await supabase.from(\"books\").select(\"content_type\", {\n            count: \"exact\"\n        }).eq(\"user_id\", user.user.id);\n        if (error) throw error;\n        const stats = {\n            total: (data === null || data === void 0 ? void 0 : data.length) || 0,\n            text: (data === null || data === void 0 ? void 0 : data.filter((b)=>b.content_type === \"text\").length) || 0,\n            video: (data === null || data === void 0 ? void 0 : data.filter((b)=>b.content_type === \"video\").length) || 0,\n            audio: (data === null || data === void 0 ? void 0 : data.filter((b)=>b.content_type === \"audio\").length) || 0,\n            pdf: (data === null || data === void 0 ? void 0 : data.filter((b)=>b.content_type === \"pdf\").length) || 0,\n            other: (data === null || data === void 0 ? void 0 : data.filter((b)=>[\n                    \"image\",\n                    \"interactive\"\n                ].includes(b.content_type)).length) || 0\n        };\n        return stats;\n    },\n    // Get unique authors\n    async getAuthors () {\n        const { data: user } = await supabase.auth.getUser();\n        if (!user.user) throw new Error(\"User not authenticated\");\n        const { data, error } = await supabase.from(\"books\").select(\"author\").eq(\"user_id\", user.user.id).not(\"author\", \"is\", null);\n        if (error) throw error;\n        // Extract unique authors\n        const authorsSet = new Set(data === null || data === void 0 ? void 0 : data.map((book)=>book.author).filter(Boolean));\n        const authors = Array.from(authorsSet).sort();\n        return authors;\n    },\n    // Get unique languages\n    async getLanguages () {\n        const { data: user } = await supabase.auth.getUser();\n        if (!user.user) throw new Error(\"User not authenticated\");\n        const { data, error } = await supabase.from(\"books\").select(\"language\").eq(\"user_id\", user.user.id);\n        if (error) throw error;\n        // Extract unique languages\n        const languagesSet = new Set(data === null || data === void 0 ? void 0 : data.map((book)=>book.language).filter(Boolean));\n        const languages = Array.from(languagesSet).sort();\n        return languages;\n    },\n    // Get content type options\n    getContentTypes () {\n        return [\n            {\n                value: \"text\",\n                label: \"Text\",\n                icon: \"\\uD83D\\uDCC4\"\n            },\n            {\n                value: \"pdf\",\n                label: \"PDF\",\n                icon: \"\\uD83D\\uDCD1\"\n            },\n            {\n                value: \"video\",\n                label: \"Video\",\n                icon: \"\\uD83C\\uDFA5\"\n            },\n            {\n                value: \"audio\",\n                label: \"Audio\",\n                icon: \"\\uD83C\\uDFA7\"\n            },\n            {\n                value: \"image\",\n                label: \"Image\",\n                icon: \"\\uD83D\\uDDBCÔ∏è\"\n            },\n            {\n                value: \"interactive\",\n                label: \"Interactive\",\n                icon: \"\\uD83C\\uDFAE\"\n            }\n        ];\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc3VwYWJhc2UvYm9va3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRFO0FBRzVFLE1BQU1DLFdBQVdELDBGQUEyQkE7QUFrQ3JDLE1BQU1FLGNBQWM7SUFDekIsc0NBQXNDO0lBQ3RDLE1BQU1DO1lBQVNDLFVBQUFBLGlFQUF1QixDQUFDO1FBQ3JDLElBQUlDLFFBQVFKLFNBQ1RLLElBQUksQ0FBQyxTQUNMQyxNQUFNLENBQUUsaVBBV1JDLEtBQUssQ0FBQyxjQUFjO1lBQUVDLFdBQVc7UUFBTTtRQUUxQyxnQkFBZ0I7UUFDaEIsSUFBSUwsUUFBUU0sTUFBTSxFQUFFO1lBQ2xCTCxRQUFRQSxNQUFNTSxFQUFFLENBQUMsZ0JBQWlEUCxPQUFqQ0EsUUFBUU0sTUFBTSxFQUFDLG9CQUF3RE4sT0FBdENBLFFBQVFNLE1BQU0sRUFBQyx5QkFBc0MsT0FBZk4sUUFBUU0sTUFBTSxFQUFDO1FBQ3pIO1FBRUEsSUFBSU4sUUFBUVEsTUFBTSxFQUFFO1lBQ2xCUCxRQUFRQSxNQUFNUSxLQUFLLENBQUMsVUFBVSxJQUFtQixPQUFmVCxRQUFRUSxNQUFNLEVBQUM7UUFDbkQ7UUFFQSxJQUFJUixRQUFRVSxVQUFVLEVBQUU7WUFDdEJULFFBQVFBLE1BQU1VLEVBQUUsQ0FBQyxlQUFlWCxRQUFRVSxVQUFVO1FBQ3BEO1FBRUEsSUFBSVYsUUFBUVksV0FBVyxFQUFFO1lBQ3ZCWCxRQUFRQSxNQUFNVSxFQUFFLENBQUMsZ0JBQWdCWCxRQUFRWSxXQUFXO1FBQ3REO1FBRUEsSUFBSVosUUFBUWEsUUFBUSxFQUFFO1lBQ3BCWixRQUFRQSxNQUFNVSxFQUFFLENBQUMsWUFBWVgsUUFBUWEsUUFBUTtRQUMvQztRQUVBLElBQUliLFFBQVFjLGVBQWUsRUFBRTtZQUMzQmIsUUFBUUEsTUFBTVUsRUFBRSxDQUFDLG9CQUFvQlgsUUFBUWMsZUFBZTtRQUM5RDtRQUVBLElBQUlkLFFBQVFlLFFBQVEsS0FBS0MsV0FBVztZQUNsQ2YsUUFB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Ly4vc3JjL2xpYi9zdXBhYmFzZS9ib29rcy50cz83NDViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudENvbXBvbmVudENsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWhlbHBlcnMtbmV4dGpzJztcbmltcG9ydCB7IEJvb2ssIENvbnRlbnRUeXBlIH0gZnJvbSAnQC90eXBlcy9kYXRhYmFzZSc7XG5cbmNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50Q29tcG9uZW50Q2xpZW50KCk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQm9va0ZpbHRlcnMge1xuICBzZWFyY2g/OiBzdHJpbmc7XG4gIGF1dGhvcj86IHN0cmluZztcbiAgY2F0ZWdvcnlJZD86IHN0cmluZztcbiAgY29udGVudFR5cGU/OiBDb250ZW50VHlwZTtcbiAgbGFuZ3VhZ2U/OiBzdHJpbmc7XG4gIHB1YmxpY2F0aW9uWWVhcj86IG51bWJlcjtcbiAgdGFncz86IHN0cmluZ1tdO1xuICBpc1B1YmxpYz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlQm9va0RhdGEge1xuICB0aXRsZTogc3RyaW5nO1xuICBhdXRob3I/OiBzdHJpbmc7XG4gIGlzYm4/OiBzdHJpbmc7XG4gIHB1Ymxpc2hlcj86IHN0cmluZztcbiAgcHVibGljYXRpb25feWVhcj86IG51bWJlcjtcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIGNhdGVnb3J5X2lkPzogc3RyaW5nO1xuICBjb250ZW50X3R5cGU6IENvbnRlbnRUeXBlO1xuICBmaWxlX3VybD86IHN0cmluZztcbiAgY292ZXJfaW1hZ2VfdXJsPzogc3RyaW5nO1xuICB0b3RhbF9wYWdlcz86IG51bWJlcjtcbiAgbGFuZ3VhZ2U6IHN0cmluZztcbiAgdGFncz86IHN0cmluZ1tdO1xuICBpc19wdWJsaWM/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZUJvb2tEYXRhIGV4dGVuZHMgUGFydGlhbDxDcmVhdGVCb29rRGF0YT4ge1xuICBpZDogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgYm9va1NlcnZpY2UgPSB7XG4gIC8vIEdldCBhbGwgYm9va3Mgd2l0aCBvcHRpb25hbCBmaWx0ZXJzXG4gIGFzeW5jIGdldEJvb2tzKGZpbHRlcnM6IEJvb2tGaWx0ZXJzID0ge30pIHtcbiAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2Jvb2tzJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICAqLFxuICAgICAgICBjYXRlZ29yeTpjYXRlZ29yaWVzKGlkLCBuYW1lLCBjb2xvciwgaWNvbiksXG4gICAgICAgIHZvY2FidWxhcnlfZ3JvdXBfYm9va3MoXG4gICAgICAgICAgdm9jYWJ1bGFyeV9ncm91cDp2b2NhYnVsYXJ5X2dyb3VwcyhcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRpZmZpY3VsdHlcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIGApXG4gICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG5cbiAgICAvLyBBcHBseSBmaWx0ZXJzXG4gICAgaWYgKGZpbHRlcnMuc2VhcmNoKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5Lm9yKGB0aXRsZS5pbGlrZS4lJHtmaWx0ZXJzLnNlYXJjaH0lLGF1dGhvci5pbGlrZS4lJHtmaWx0ZXJzLnNlYXJjaH0lLGRlc2NyaXB0aW9uLmlsaWtlLiUke2ZpbHRlcnMuc2VhcmNofSVgKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGZpbHRlcnMuYXV0aG9yKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmlsaWtlKCdhdXRob3InLCBgJSR7ZmlsdGVycy5hdXRob3J9JWApO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZmlsdGVycy5jYXRlZ29yeUlkKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdjYXRlZ29yeV9pZCcsIGZpbHRlcnMuY2F0ZWdvcnlJZCk7XG4gICAgfVxuICAgIFxuICAgIGlmIChmaWx0ZXJzLmNvbnRlbnRUeXBlKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LmVxKCdjb250ZW50X3R5cGUnLCBmaWx0ZXJzLmNvbnRlbnRUeXBlKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGZpbHRlcnMubGFuZ3VhZ2UpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ2xhbmd1YWdlJywgZmlsdGVycy5sYW5ndWFnZSk7XG4gICAgfVxuICAgIFxuICAgIGlmIChmaWx0ZXJzLnB1YmxpY2F0aW9uWWVhcikge1xuICAgICAgcXVlcnkgPSBxdWVyeS5lcSgncHVibGljYXRpb25feWVhcicsIGZpbHRlcnMucHVibGljYXRpb25ZZWFyKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGZpbHRlcnMuaXNQdWJsaWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnaXNfcHVibGljJywgZmlsdGVycy5pc1B1YmxpYyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChmaWx0ZXJzLnRhZ3MgJiYgZmlsdGVycy50YWdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkuY29udGFpbnMoJ3RhZ3MnLCBmaWx0ZXJzLnRhZ3MpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5O1xuICAgIFxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgcmV0dXJuIGRhdGEgYXMgQm9va1tdO1xuICB9LFxuXG4gIC8vIEdldCBzaW5nbGUgYm9vayBieSBJRFxuICBhc3luYyBnZXRCb29rKGlkOiBzdHJpbmcpIHtcbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2Jvb2tzJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICAqLFxuICAgICAgICBjYXRlZ29yeTpjYXRlZ29yaWVzKGlkLCBuYW1lLCBjb2xvciwgaWNvbiksXG4gICAgICAgIGNvdXJzZV9ib29rcyhcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBjb3Vyc2VfaWQsXG4gICAgICAgICAgaXNfcmVxdWlyZWQsXG4gICAgICAgICAgbm90ZXMsXG4gICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgY291cnNlOmNvdXJzZXMoaWQsIHRpdGxlLCBzdGF0dXMpXG4gICAgICAgIClcbiAgICAgIGApXG4gICAgICAuZXEoJ2lkJywgaWQpXG4gICAgICAuc2luZ2xlKCk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICByZXR1cm4gZGF0YSBhcyBCb29rO1xuICB9LFxuXG4gIC8vIENyZWF0ZSBuZXcgYm9va1xuICBhc3luYyBjcmVhdGVCb29rKGJvb2tEYXRhOiBDcmVhdGVCb29rRGF0YSkge1xuICAgIGNvbnN0IHsgZGF0YTogdXNlciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gICAgaWYgKCF1c2VyLnVzZXIpIHRocm93IG5ldyBFcnJvcignVXNlciBub3QgYXV0aGVudGljYXRlZCcpO1xuXG4gICAgLy8gU2V0IGRlZmF1bHQgbGFuZ3VhZ2UgaWYgbm90IHByb3ZpZGVkXG4gICAgY29uc3QgZGF0YVdpdGhEZWZhdWx0cyA9IHtcbiAgICAgIC4uLmJvb2tEYXRhLFxuICAgICAgbGFuZ3VhZ2U6IGJvb2tEYXRhLmxhbmd1YWdlIHx8ICdlbicsXG4gICAgICBpc19wdWJsaWM6IGJvb2tEYXRhLmlzX3B1YmxpYyB8fCBmYWxzZSxcbiAgICAgIHVzZXJfaWQ6IHVzZXIudXNlci5pZCxcbiAgICB9O1xuXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdib29rcycpXG4gICAgICAuaW5zZXJ0KGRhdGFXaXRoRGVmYXVsdHMpXG4gICAgICAuc2VsZWN0KClcbiAgICAgIC5zaW5nbGUoKTtcbiAgICBcbiAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICAgIHJldHVybiBkYXRhIGFzIEJvb2s7XG4gIH0sXG5cbiAgLy8gVXBkYXRlIGJvb2tcbiAgYXN5bmMgdXBkYXRlQm9vayh7IGlkLCAuLi5ib29rRGF0YSB9OiBVcGRhdGVCb29rRGF0YSkge1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYm9va3MnKVxuICAgICAgLnVwZGF0ZSh7XG4gICAgICAgIC4uLmJvb2tEYXRhLFxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9KVxuICAgICAgLmVxKCdpZCcsIGlkKVxuICAgICAgLnNlbGVjdCgpXG4gICAgICAuc2luZ2xlKCk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICByZXR1cm4gZGF0YSBhcyBCb29rO1xuICB9LFxuXG4gIC8vIERlbGV0ZSBib29rXG4gIGFzeW5jIGRlbGV0ZUJvb2soaWQ6IHN0cmluZykge1xuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnYm9va3MnKVxuICAgICAgLmRlbGV0ZSgpXG4gICAgICAuZXEoJ2lkJywgaWQpO1xuICAgIFxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gIH0sXG5cbiAgLy8gR2V0IGJvb2sgc3RhdGlzdGljc1xuICBhc3luYyBnZXRCb29rU3RhdHMoKSB7XG4gICAgY29uc3QgeyBkYXRhOiB1c2VyIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICBpZiAoIXVzZXIudXNlcikgdGhyb3cgbmV3IEVycm9yKCdVc2VyIG5vdCBhdXRoZW50aWNhdGVkJyk7XG5cbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ2Jvb2tzJylcbiAgICAgIC5zZWxlY3QoJ2NvbnRlbnRfdHlwZScsIHsgY291bnQ6ICdleGFjdCcgfSlcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIudXNlci5pZCk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcblxuICAgIGNvbnN0IHN0YXRzID0ge1xuICAgICAgdG90YWw6IGRhdGE/Lmxlbmd0aCB8fCAwLFxuICAgICAgdGV4dDogZGF0YT8uZmlsdGVyKGIgPT4gYi5jb250ZW50X3R5cGUgPT09ICd0ZXh0JykubGVuZ3RoIHx8IDAsXG4gICAgICB2aWRlbzogZGF0YT8uZmlsdGVyKGIgPT4gYi5jb250ZW50X3R5cGUgPT09ICd2aWRlbycpLmxlbmd0aCB8fCAwLFxuICAgICAgYXVkaW86IGRhdGE/LmZpbHRlcihiID0+IGIuY29udGVudF90eXBlID09PSAnYXVkaW8nKS5sZW5ndGggfHwgMCxcbiAgICAgIHBkZjogZGF0YT8uZmlsdGVyKGIgPT4gYi5jb250ZW50X3R5cGUgPT09ICdwZGYnKS5sZW5ndGggfHwgMCxcbiAgICAgIG90aGVyOiBkYXRhPy5maWx0ZXIoYiA9PiBbJ2ltYWdlJywgJ2ludGVyYWN0aXZlJ10uaW5jbHVkZXMoYi5jb250ZW50X3R5cGUpKS5sZW5ndGggfHwgMCxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHN0YXRzO1xuICB9LFxuXG4gIC8vIEdldCB1bmlxdWUgYXV0aG9yc1xuICBhc3luYyBnZXRBdXRob3JzKCkge1xuICAgIGNvbnN0IHsgZGF0YTogdXNlciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gICAgaWYgKCF1c2VyLnVzZXIpIHRocm93IG5ldyBFcnJvcignVXNlciBub3QgYXV0aGVudGljYXRlZCcpO1xuXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdib29rcycpXG4gICAgICAuc2VsZWN0KCdhdXRob3InKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci51c2VyLmlkKVxuICAgICAgLm5vdCgnYXV0aG9yJywgJ2lzJywgbnVsbCk7XG4gICAgXG4gICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcblxuICAgIC8vIEV4dHJhY3QgdW5pcXVlIGF1dGhvcnNcbiAgICBjb25zdCBhdXRob3JzU2V0ID0gbmV3IFNldChkYXRhPy5tYXAoYm9vayA9PiBib29rLmF1dGhvcikuZmlsdGVyKEJvb2xlYW4pKTtcbiAgICBjb25zdCBhdXRob3JzID0gQXJyYXkuZnJvbShhdXRob3JzU2V0KS5zb3J0KCk7XG4gICAgcmV0dXJuIGF1dGhvcnM7XG4gIH0sXG5cbiAgLy8gR2V0IHVuaXF1ZSBsYW5ndWFnZXNcbiAgYXN5bmMgZ2V0TGFuZ3VhZ2VzKCkge1xuICAgIGNvbnN0IHsgZGF0YTogdXNlciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gICAgaWYgKCF1c2VyLnVzZXIpIHRocm93IG5ldyBFcnJvcignVXNlciBub3QgYXV0aGVudGljYXRlZCcpO1xuXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdib29rcycpXG4gICAgICAuc2VsZWN0KCdsYW5ndWFnZScpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLnVzZXIuaWQpO1xuICAgIFxuICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG5cbiAgICAvLyBFeHRyYWN0IHVuaXF1ZSBsYW5ndWFnZXNcbiAgICBjb25zdCBsYW5ndWFnZXNTZXQgPSBuZXcgU2V0KGRhdGE/Lm1hcChib29rID0+IGJvb2subGFuZ3VhZ2UpLmZpbHRlcihCb29sZWFuKSk7XG4gICAgY29uc3QgbGFuZ3VhZ2VzID0gQXJyYXkuZnJvbShsYW5ndWFnZXNTZXQpLnNvcnQoKTtcbiAgICByZXR1cm4gbGFuZ3VhZ2VzO1xuICB9LFxuXG4gIC8vIEdldCBjb250ZW50IHR5cGUgb3B0aW9uc1xuICBnZXRDb250ZW50VHlwZXMoKTogeyB2YWx1ZTogQ29udGVudFR5cGU7IGxhYmVsOiBzdHJpbmc7IGljb24/OiBzdHJpbmcgfVtdIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyB2YWx1ZTogJ3RleHQnLCBsYWJlbDogJ1RleHQnLCBpY29uOiAn8J+ThCcgfSxcbiAgICAgIHsgdmFsdWU6ICdwZGYnLCBsYWJlbDogJ1BERicsIGljb246ICfwn5ORJyB9LFxuICAgICAgeyB2YWx1ZTogJ3ZpZGVvJywgbGFiZWw6ICdWaWRlbycsIGljb246ICfwn46lJyB9LFxuICAgICAgeyB2YWx1ZTogJ2F1ZGlvJywgbGFiZWw6ICdBdWRpbycsIGljb246ICfwn46nJyB9LFxuICAgICAgeyB2YWx1ZTogJ2ltYWdlJywgbGFiZWw6ICdJbWFnZScsIGljb246ICfwn5a877iPJyB9LFxuICAgICAgeyB2YWx1ZTogJ2ludGVyYWN0aXZlJywgbGFiZWw6ICdJbnRlcmFjdGl2ZScsIGljb246ICfwn46uJyB9LFxuICAgIF07XG4gIH0sXG59O1xuIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudENvbXBvbmVudENsaWVudCIsInN1cGFiYXNlIiwiYm9va1NlcnZpY2UiLCJnZXRCb29rcyIsImZpbHRlcnMiLCJxdWVyeSIsImZyb20iLCJzZWxlY3QiLCJvcmRlciIsImFzY2VuZGluZyIsInNlYXJjaCIsIm9yIiwiYXV0aG9yIiwiaWxpa2UiLCJjYXRlZ29yeUlkIiwiZXEiLCJjb250ZW50VHlwZSIsImxhbmd1YWdlIiwicHVibGljYXRpb25ZZWFyIiwiaXNQdWJsaWMiLCJ1bmRlZmluZWQiLCJ0YWdzIiwibGVuZ3RoIiwiY29udGFpbnMiLCJkYXRhIiwiZXJyb3IiLCJnZXRCb29rIiwiaWQiLCJzaW5nbGUiLCJjcmVhdGVCb29rIiwiYm9va0RhdGEiLCJ1c2VyIiwiYXV0aCIsImdldFVzZXIiLCJFcnJvciIsImRhdGFXaXRoRGVmYXVsdHMiLCJpc19wdWJsaWMiLCJ1c2VyX2lkIiwiaW5zZXJ0IiwidXBkYXRlQm9vayIsInVwZGF0ZSIsInVwZGF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJkZWxldGVCb29rIiwiZGVsZXRlIiwiZ2V0Qm9va1N0YXRzIiwiY291bnQiLCJzdGF0cyIsInRvdGFsIiwidGV4dCIsImZpbHRlciIsImIiLCJjb250ZW50X3R5cGUiLCJ2aWRlbyIsImF1ZGlvIiwicGRmIiwib3RoZXIiLCJpbmNsdWRlcyIsImdldEF1dGhvcnMiLCJub3QiLCJhdXRob3JzU2V0IiwiU2V0IiwibWFwIiwiYm9vayIsIkJvb2xlYW4iLCJhdXRob3JzIiwiQXJyYXkiLCJzb3J0IiwiZ2V0TGFuZ3VhZ2VzIiwibGFuZ3VhZ2VzU2V0IiwibGFuZ3VhZ2VzIiwiZ2V0Q29udGVudFR5cGVzIiwidmFsdWUiLCJsYWJlbCIsImljb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/supabase/books.ts\n"));

/***/ })

});